server <- function(input, output, session) {
  documentReadyPainter() # Restyle some elements with JavaScript.

  ## NOTE: Disable the stochastic radio button and the R0 nav tab, respectively.
  ## When these are implemented the respective line can be removed.
  disable(selector = "#stochastic > div:nth-child(2) > label:nth-child(2) > input:nth-child(1)")
  disable(selector = "li.nav-item:nth-child(5) > a:nth-child(1)")
  disable(selector = "button.collapse-toggle")
  runjs(r"--($('button.collapse-toggle').hide())--")

  updateNumericInputs <- function(defaults, session) {
    if (any(is.null(dim(defaults)), dim(defaults)[1] != 1)) {
      warning("The `defaults` dataframe is not a single row!")
      print(defaults)
    }
    iwalk(defaults, \(value, inputId) {
      updateNumericInput(session, inputId, value = value)
    })
  }

  renderNumericInputWithMathJax <-
    function(inputId, label) {
      numericInputWithMathJax <-
        withMathJax(numericInput(
          inputId,
          label,
          0.5,
          min = 0,
          max = 3,
          step = 0.01,
          width = "300px"
        ))
      ## Evaluate the renderUI function call in the parent environment, so the
      ## expected environment that renderUI runs in is the server function
      ## scope, rather than below another function. numericInputWithMathJax is
      ## substituted, so renderUI it is the already-evaluated result of the
      ## above assignment expresison.
      eval.parent(bquote(renderUI({ .(numericInputWithMathJax) })))
    }

  ## Add all of the rules generated by rule function factories to a validator.
  addRuleListToValidator <- function(validator, ruleList) {
    mapply(
      function(inputId, ruleVector) {
        validator$add_rule(inputId, sv_required())
        ## NOTE: inputId intentionally recycled ♺!
        mapply(validator$add_rule, inputId, ruleVector)
      },
      names(ruleList),
      ruleList
    )

    validator$enable()
    invisible(validator)
  }

  globalValidator <- addRuleListToValidator(
    InputValidator$new(),
    filter(rules, is.na(model))[, 2][[1]][[1]]
  )

  validatorsAndLambdas <-
    filter(rules, !is.na(model)) |>
    rowwise() |>
    mutate(
      vld = list(addRuleListToValidator(InputValidator$new(), ruleList)),
      lambda = list(eval(bquote(\() input$modelSelect == .(model))))
    ) |>
    select(vld, lambda)

  isolate(
    mapply(
      FUN = \(validator, lambda) {
        validator$condition(lambda)
        globalValidator$add_validator(validator)
      },
      validatorsAndLambdas[[1]],
      validatorsAndLambdas[[2]]
    )
  )

  defaults <- reactive({
    if (!(input$modelSelect %in% "")) {
      filter(
        defaultInputValues,
        modelType == input$modelSelect,
        ## WARN DONT: compare numerical booleans following C style; using
        ## logicals in any way—coercing numeric to logical on the RHS or using
        ## logical values in the defaultInputValues—seems to bork everything.
        stochastic == input$stochastic,
        vitalDynamics == input$vitalDynamics,
        massAction == input$trueMassAction
      ) |>
        select(beta:replicates) |>
        select(where(\(x) all(!is.na(x))))
    }
  })

  output$modelDiagram <- renderUI({
    req(input$modelSelect)
    if (!(input$modelSelect %in% "")) {
      tagList(
        img(
          src = paste0("images/", input$modelSelect, ".png"),
          contentType = "image/png",
          height = "40px",
          alt = gsub("\n[\t\ ]+?", " ", r"(The diagram of the model compartments
                     failed to load, or the accessibility text is being read by
                     a screen reader.)")
        )
      )
    }
  })

  modellingFunctions <-
    reactive({
      mget(
        paste0(
          c("solve", "plot", "plotSubPlots", "plotPhasePlane"),
          input$modelSelect
        ),
        envir = environment(solveSusceptibleInfected),
        mode = "function"
      )
    })

  ## Whenever the model selection changes, the widget values throughout the
  ## application are updated according to the defaults specified for the model
  ## configuration in the defaultInputValues.xlsx spreadsheet in the data/
  ## project subfolder.
  observeEvent(input$modelSelect, {
    if (input$modelSelect %in% "") {
      hide("actionButtons")
      hide("modelConfiguration")
    } else {
      hide("outputPanel")
      if (grepl("SI", input$modelSelect, ignore.case = TRUE)) {
        output$beta <- renderNumericInputWithMathJax("beta", r"[Rate of infection (\(\beta\))]")
        output$gamma <- renderNumericInputWithMathJax("gamma", r"[Rate of recovery (\(\gamma\))]")
      } else if (grepl("SEI", input$modelSelect, ignore.case = TRUE)) {
        output$beta <- renderNumericInputWithMathJax("beta", r"[Rate of exposure (\(\beta\))]")
        output$gamma <- renderNumericInputWithMathJax("gamma", r"[Rate of infection (\(\gamma\))]")
      }
      updateNumericInputs(defaults(), session)
      show("modelConfiguration")
      show("actionButtons")
    }
  })

  createSubPlotsUI <- function(ggplots) {
    imap(ggplots, \(plot, index) {
      plotName <- paste0("subplot.", index)
      output[[plotName]] <- renderPlotly({ ggplotly(plot) })
      column(6, plotlyOutput(plotName))
    }) |>
      fluidRow()
  }

  observeEvent(input$stochasticSelect, {
    hide("outputPanel") # TODO: the outputPanel should be reactive!
    updateNumericInputs(defaults(), session)
  })

  ## Remove the inputs which are currently hidden from the reactive value under
  ## construction herein.
  visibleInputs <- reactive({
    allInputs <- reactiveValuesToList(input)
    nameAmongHiddenInputs <-
      names(allInputs) %in% c(input$hiddenInputs, "hiddenInputs")
    visibleInputs <- allInputs[!nameAmongHiddenInputs]
    stopifnot(is.list(visibleInputs))
    return(visibleInputs)
  })

  observeEvent(input$go, {
    show("outputPanel")

    modelSolver <- modellingFunctions()[[1]]
    modelPlotter <- modellingFunctions()[[2]]
    modelSubPlotter <- modellingFunctions()[[3]]
    modelPhasePlanePlotter <- modellingFunctions()[[4]]

    ## NOTE: if the D compartment is not enabled, it's column is removed from
    ## the dataframe. D would always equal zero if not enabled.
    modelResults <- doCall(modelSolver, args = visibleInputs()) |>
      select(c(time, N, matches(str_split_1(input$modelSelect, ""))))

    ## FIXME: the number of deriviatives returned is not equal to the number of
    ## variables provided to lsoda when running an SEI-type model. This is
    ## strange, and I'm unsure why that's happening, having read the code I
    ## wrote multiple times.
    ##
    ## modelResultsFromExposuRe <-
    ##   doCall(exposuRe, args = visibleInputs()) |>
    ##   select(c(time, N, matches(str_split_1(input$modelSelect, ""))))
    ##
    ## printf("%s model results equal regardless of solveR? %s",
    ##        input$modelSelect,
    ##        if(equals(modelResults, modelResultsFromExposuRe)) "YES."
    ##        else "NO.") |>
    ##   print()

    output$modelPlot <-
      renderPlotly(ggplotly(modelPlotter(modelResults)))

    output$modelSubPlots <-
      renderUI(createSubPlotsUI(modelSubPlotter(modelResults)))

    output$modelPhasePlane <-
      renderPlotly(ggplotly(modelPhasePlanePlotter(modelResults)))

    output$modelSummaryTable <- renderDT({
      datatable(round(modelResults, 2),
                options = list(dom = "lprti", pageLength = 50),
                rownames = FALSE)
    })

    output$modelLaTeX <-
      doCall(renderModelLaTeX, args = visibleInputs()) |> renderUI()

    output$downloadData <-
      downloadHandler(
        \() paste0(input$modelSelect, "_Model_Summary", Sys.Date(), ".xlsx"),
        \(file) write_xlsx(modelResults, file))
  })

  observeEvent(input$resetAll, {
    hide("outputPanel")
    hide("actionButtons")
    hide("modelConfiguration")
    updatePickerInput(session, "modelSelect", selected = "")
    updateRadioButtons(session, "trueMassAction", selected = 0)
    updateRadioButtons(session, "stochasticSelect", selected = 0)
    updateCheckboxInput(session, "vitalDynamics", value = FALSE)
    updateNumericInputs(defaults(), session)
  })

  ## HACK: wrapping input in a reactive, despite it already being a reactive
  ## value, allows the observable to depend on all inputs simultaneously, and
  ## forces the expression to be recalculated whenever any input is changed,
  ## because the reactive value allInput() will be invalidated and recalculated.
  ## Returning NULL or something else in the reactive wouldn't work; the value
  ## needs to be dependent on all inputs, so invisibly returning all inputs is a
  ## useful hack to quickly solve the issue.
  inputs <- reactive({ invisible(input) })
  ## NOTE: ignore the value of the reactive expression; calling it predicates
  ## this check on all visible inputs.
  observe({
    inputs()
    if (globalValidator$is_valid()) enable("go") else disable("go")
  })
}
