server <- function(input, output, session) {
# Functions, such as the solveAndRender dispatcher -----------------------------
  ## NOTE: params is checked for being NA to protect against the default
  ## case_when in an observe. It does nothing otherwise.
  updateNumericInputs <- function(params, session = getDefaultReactiveDomain()) {
    mapply(
        function(inputId, value) {
          updateNumericInput(session, inputId = inputId, value = value)
        },
        inputId = names(params),
        value = params
      )
  }

  ## Add all of the rules generated by rule function factories to a validator,
  ## and optionally condition those rules on condition.
  addRuleListToValidator <- function(validator, ruleList) {
    mapply(
      function(inputId, ruleVector) {
        ## inputId is intentionally recycled while adding the rules in
        ## ruleVector.
        mapply(validator$add_rule, inputId, ruleVector)
        validator$add_rule(inputId, sv_required())
      },
      names(ruleList),
      ruleList
    )

    ## Enable the validator and return it invisibly.
    validator$enable()
    invisible(validator)
  }


# Validation --------------------------------------------------------------
  ## NOTE: all inputs have the required rule automatically added.
  globalValidator <-
    addRuleListToValidator(InputValidator$new(),
                           filter(rules, is.na(model))[, 2][[1]])

  filter(rules, !is.na(model)) |>
    apply(
      MARGIN = 1,
      FUN = function(model) {
        modelValidator <- c(model$name, "Validator")
        assign(modelValidator, InputValidator$new(), envir = .GlobalEnv)
        addRuleListToValidator(get(modelValidator, envir = .GlobalEnv),
                               model$rules)
      }
    )

# Reactives ---------------------------------------------------------------
  ## TODO: the function must handle NAs appropriately, such that a widget
  ## is hidden when the value is NA rather than set to an invalid state.
  defaults <- reactive({
    if(input$modelSelect %in% "") {
      ## NOTE: Restore defaults() value to the full dataframe; this isn't
      ## strictly necessary, it's just a sort ofo "reset". defaults() won't be
      ## used when the model selection is "", but I think it may rule out some
      ## very strange state issues if we just ensure that there are rows in the
      ## dataframe rather than having a zero-length issue. Who knows. ðŸ¤·
      defaultInputValues
    } else {
      filter(
        defaultInputValues,
        modelType == input$modelSelect,
        stochastic == input$stochasticSelect,
        vitalStatistics == input$vitalStatistics,
        massAction == input$massActionSelect
      ) |>
        select(beta:replicates) |>
        select(where(\(x) all(!is.na(x)))) |>
        as.list()
    }
  })

  ## alias model-specific symbols to the unified solver function for SE-type
  ## models.
  solveSEIR <- solveSEIRS <- solveSEIRD <- solveSusceptibleExposed
  solveSIR <- solveSIRS <- solveSIRD <- solveSusceptibleInfected
  modellingFunctions <-
    reactive({
      mget(paste0(c("solve", "plot", "plotPhasePlane"),
                  input$modelSelect),
           envir = environment(solveSIR),
           mode = "function")
    })

# Observables -------------------------------------------------------------
# MODEL SELECT: update numeric inputs to model defaults on change. --------
  ## Whenever the model selection changes (whether the parameters and variables
  ## are set manually or taken from pre-defined models), the widget values
  ## throughout the application are updated as appropriate.
  observeEvent(input$modelSelect, {
    ## If no model is selected, hide the model configuration and action buttons.
    if (input$modelSelect %in% "") {
      hide("actionButtons")
      hide("modelConfiguration")
    } else {
      ## Validation
      ## NOTE: when the selected model is changed the condition for that validator
      ## object (for the selected model) is set to TRUE, and all other
      ## model-specific validators' condition is set to FALSE.
### FIXME:
      ## Warning: Error in get: object 'SIRSValidator' not found
      ## 44: get
      ## 38: server [/home/bryce/Documents/src/r/episim/server.R#80]
      ##  1: runApp
      ## Error in get(paste0(model, "Validator"), envir = .GlobalEnv) :
      ##   object 'SIRSValidator' not found
      for(model in c("SIR", "SIRS", "SIRD", "SEIR", "SEIRS", "SEIRD")) {
        modelValidator <- get(paste0(model, "Validator"), envir = .GlobalEnv)
        modelValidator$condition(input$modelSelect == model)
        ## NOTE: while this is re-run every time the model is changed, it will
        ## only have an effect a single time, and there will neither be multiple
        ## references to the child validator in the list of children of this
        ## validator (the global one), nor will there be any side-effects.
        globalValidator$add_validator(modelValidator)
      }

      ## Widget visibility and labelling
      hide("outputPanel")
      updateNumericInputs(defaults())
      ## NOTE: this triggers the anonymous function in
      ## www/whenModelSelectChangesTypesetLaTeX.js to be called, typesetting the
      ## updated labels.
      if(grepl("SI", input$modelSelect, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[Rate of infection ($ \beta $)]")
        updateNumericInput(session, "gamma", r"[Rate of recovery ($ \gamma $)]")
      } else if(grepl("SEI", input$modelSelect, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[Rate of exposure ($ \beta $)]")
        updateNumericInput(session, "gamma", r"[Rate of infection ($ \gamma $)]")
      }
      show("modelConfiguration")
      show("actionButtons")
    }
  })

# StochasticSelect --------------------------------------------------------
  ## NOTE: hide the output panel and update the input widgets with defaults when
  ## the user changes to stochastic modelling.
  observeEvent(input$stochasticSelect, {
    hide("outputPanel")
    updateNumericInputs(defaults())
  })

# GO: show outputPanel; call modelling function; render LaTeX. ------------
  ## Toggle the visibility of the outputPanel based on the user's interactions
  ## with the "go" actionButton.
  observeEvent(input$go, {
    show("outputPanel")

    modelSolver <- modellingFunctions()[[1]]
    modelPlotter <- modellingFunctions()[[2]]
    modelPhasePlanePlotter <- modellingFunctions()[[3]]

    eval(substitute({
      modelResults <- doCall.default(.fcn = modelSolver,
                                     args = reactiveValuesToList(input),
                                     .ignoreUnusedArguments = TRUE)
      output$modelPlot <- renderPlot(modelPlotter(modelResults))
      output$modelPhasePlane <- renderPlot(modelPhasePlanePlotter(modelResults))
      output$modelSummaryTable <- renderTable(modelResults[, 1:6])

      output$modelLaTeX <- renderUI(renderModelLaTeX())
    }))
  })

# RESET: hide outputPanel; modelConfiguration; actionButtons; rese --------
  ## TODO: resetting the application should set the widget values to those which
  ## are defined for the model in the spreadsheet.
  observeEvent(input$resetAll, {
    ## Widget visibility
    hide("outputPanel")
    hide("actionButtons")
    hide("modelConfiguration")

    ## Model options widget values
    updatePickerInput(session, "modelSelect", selected = "")
    updateRadioButtons(session, "massActionSelect", selected = 0)
    updateRadioButtons(session, "stochasticSelect", selected = 0)
    updateCheckboxInput(session, "vitalStatistics", value = FALSE)

    ## Simulation options widget values
    updateNumericInput(session, "timesteps", value = 100)
  })

  ## FIXME: the input is not being validated properly, because the global
  ## validator is returning the incorrect value and "go" is never being enabled.
  ## observeEvent(input, {
  ##   if(globalValidator$is_valid()) {
  ##     enable("go")
  ##   } else {
  ##     disable("go")
  ##   }
  ## })
}
