server <- function(input, output, session) {
  documentReadyPainter() # Restyle some elements with JavaScript.

  ## NOTE: Disable the stochastic radio button and the R0 nav tab, respectively.
  ## When these are implemented the respective line can be removed.
  disable(selector = "#stochastic > div:nth-child(2) > label:nth-child(2) > input:nth-child(1)")
  disable(selector = "li.nav-item:nth-child(5) > a:nth-child(1)")
  disable(selector = "button.collapse-toggle")
  runjs(r"--($('button.collapse-toggle').hide())--")

  updateNumericInputs <- function(defaults, session) {
    if (any(is.null(dim(defaults)), dim(defaults)[1] != 1)) {
      warning("The `defaults` dataframe is not a single row!")
      print(defaults)
    }
    iwalk(defaults, \(value, inputId) {
      updateNumericInput(session, inputId, value = value)
    })
  }

  numericInputWithMathJax <-
    function(inputId, rateLabel, initialValue) {
      withMathJax(numericInput(
        inputId,
        sprintf(r"[Rate of %s (\(\%s\))]", rateLabel, inputId),
        value = initialValue,
        min = 0,
        max = 1,
        step = 0.01,
        width = "300px"
      ))
    }

  ## Add all of the rules generated by rule function factories to a validator;
  ## do not apply the functions if the list of inputs and rule vectors is empty
  ## (ruleList) is empty, or if the vector of rules for a single input is empty.
  addRuleListToValidator <- function(validator, ruleList) {
    if(length(ruleList)) {
      mapply(
        function(inputId, ruleVector) {
          validator$add_rule(inputId, sv_required())
          if(length(ruleVector)) {
            ## inputId is intentionally recycled ♺!
            mapply(validator$add_rule, inputId, ruleVector)
          }
        },
        names(ruleList),
        ruleList
      )
    }

    validator$enable()
    invisible(validator)
  }

  globalValidator <- addRuleListToValidator(
    InputValidator$new(),
    filter(rules, is.na(model))[, 2][[1]][[1]]
  )

  validatorsAndLambdas <-
    filter(rules, !is.na(model)) |>
    rowwise() |>
    mutate(
      vld = list(addRuleListToValidator(InputValidator$new(), ruleList)),
      lambda = list(eval(bquote(\() {
        print(sprintf("%s's input validator condition passes? %s",
                      .(model),
                      grepl(.(model), input$modelSelect)))
        grepl(.(model), input$modelSelect)
        })))
    ) |>
    select(vld, lambda)

  isolate(
    mapply(
      FUN = \(validator, lambda) {
        validator$condition(lambda)
        globalValidator$add_validator(validator)
      },
      validatorsAndLambdas[[1]],
      validatorsAndLambdas[[2]]
    )
  )

  defaults <- reactive({
    defaultInputValues |>
      filter(
        modelType == req(input$modelSelect),
        ## WARN DONT: compare numerical booleans following C style; using
        ## logicals in any way—coercing numeric to logical on the RHS or using
        ## logical values in the defaultInputValues—seems to bork everything.
        stochastic == input$stochastic,
        vitalDynamics == input$vitalDynamics,
        massAction == input$trueMassAction
      ) |>
      select(beta:replicates) |>
      select(where(\(x) all(!is.na(x))))
  })

  modellingFunctions <-
    reactive({
      mget(
        paste0(
          c("plot", "plotSubPlots", "plotPhasePlane"),
          req(input$modelSelect)
        ),
        envir = environment(exposuRe),
        mode = "function"
      )
    })

  ## Whenever the model selection changes, the widget values throughout the
  ## application are updated according to the defaults specified for the model
  ## configuration in the defaultInputValues.xlsx spreadsheet in the data/
  ## project subfolder.
  observeEvent(input$modelSelect, {
    hide("outputPanel")
    req(defaults())
    exposedEnabled <- substr(input$modelSelect, 2, 2) == "E"
    output$beta <- renderUI({
      rateLabel <- { if (exposedEnabled) "exposure" else "infection" }
      defaultValue <- select(defaults(), beta) |> as.numeric()
      stopifnot(is.numeric(defaultValue) && length(defaultValue) == 1)
      numericInputWithMathJax("beta", rateLabel, defaultValue)
    })
    output$gamma <- renderUI({
      rateLabel <- { if (exposedEnabled) "infection" else "recovery" }
      defaultValue <- select(defaults(), gamma) |> as.numeric()
      stopifnot(is.numeric(defaultValue) && length(defaultValue) == 1)
      numericInputWithMathJax("gamma", rateLabel, defaultValue)
    })
    updateNumericInputs(defaults(), session)
  })

  observeEvent({ # Any of these three inputs will cause a "partial reset."
    input$stochasticSelect
    input$trueMassAction
    input$vitalDynamics
    }, {
    hide("outputPanel")
    updateNumericInputs(defaults(), session)
  })

  ## Remove the inputs which are currently hidden from the reactive value under
  ## construction herein.
  visibleInputs <- reactive({
    allInputs <- reactiveValuesToList(input)
    nameAmongHiddenInputs <-
      names(allInputs) %in% c(input$hiddenInputs, "hiddenInputs")
    visibleInputs <- allInputs[!nameAmongHiddenInputs]
    stopifnot(is.list(visibleInputs))
    return(visibleInputs)
  })

  observeEvent(input$go, {
    show("outputPanel")

    modelPlotter <- modellingFunctions()[[1]]
    modelSubPlotter <- modellingFunctions()[[2]]
    modelPhasePlanePlotter <- modellingFunctions()[[3]]

    modelResults <-
      doCall(exposuRe, args = visibleInputs()) |>
      select(c(time, N, matches(str_split_1(input$modelSelect, ""))))

    output$modelPlot <-
      renderPlotly(ggplotly(modelPlotter(modelResults)))

    output$modelSubPlots <-
      modelSubPlotter(modelResults) |>
      imap(\(plot, index) {
        plotName <- paste0("subplot.", index)
        output[[plotName]] <- renderPlotly({
          ggplotly(plot)
        })
        column(6, plotlyOutput(plotName))
      }) |>
      fluidRow() |>
      renderUI()

    output$modelPhasePlane <-
      renderPlotly(ggplotly(modelPhasePlanePlotter(modelResults)))

    output$modelSummaryTable <- renderDT({
      datatable(round(modelResults, 2),
                options = list(dom = "lprti", pageLength = 50),
                rownames = FALSE)
    })

    output$modelLaTeX <-
      doCall(renderModelLaTeX, args = visibleInputs()) |> renderUI()

    output$modelDiagram <- renderUI({
      tagList(
        img(
          src = paste0("images/", req(input$modelSelect), ".svg"),
          contentType = "image/svg",
          width = "420px",
          alt = gsub("\n[\t\ ]+?", " ", r"(The diagram of the model compartments
                     failed to load, or the accessibility text is being read by
                     a screen reader.)")
        )
      )
    })

    output$downloadData <-
      downloadHandler(
        \() paste0(input$modelSelect, "_Model_Summary", Sys.Date(), ".xlsx"),
        \(file) write_xlsx(modelResults, file))
  })

  observeEvent(input$resetAll, {
    hide("outputPanel")
    updatePickerInput(session, "modelSelect", selected = "")
    updateRadioButtons(session, "trueMassAction", selected = 0)
    updateRadioButtons(session, "stochasticSelect", selected = 0)
    updateCheckboxInput(session, "vitalDynamics", value = FALSE)
    updateNumericInputs(defaults(), session)
  })

  ## HACK: wrapping input in a reactive, despite it already being a reactive
  ## value, allows the observable to depend on all inputs simultaneously, and
  ## forces the expression to be recalculated whenever any input is changed,
  ## because the reactive value inputs() will be invalidated and recalculated.
  ## Returning NULL or something else in the reactive wouldn't work; the value
  ## needs to be dependent on all inputs, so invisibly returning all inputs is a
  ## useful hack to quickly solve the issue.
  inputs <- reactive({ invisible(input) })
  ## NOTE: ignore the value of the reactive expression; calling it predicates
  ## this check on all visible inputs.
  observe({
    inputs()
    if (globalValidator$is_valid()) enable("go") else disable("go")
  })
}
