server <- function(input, output, session) {
  ## NOTE: Remove the btn-light class from the model select button to make its
  ## interior have a white background, rather than a light background matching
  ## the surrounding sidepanel.
  runjs(r"[$(document).ready($('#modelSelect + button').removeClass('btn-light'))]")
  r"($(document)
     .ready($('div:has(> #modelSelect)')
            .css({
            'border':'var(--bs-border-width) solid #8D959E',
            'border-radius':'var(--bs-border-radius)',
            'transition':'border-color 0.15s ease-in-out,box - shadow 0.15 s ease - in - out '
            })
     )
    )" |>
  gsub(pattern = r"(\n\s*)", replacement = "") |>
  runjs()

  ## NOTE: hack on the styling of the vitalDynamics widget group.
  r"[$(document).ready($('#vitalDynamics-card).css('padding', '10px'))]" |>
    gsub(pattern = r"(\n\s*)", replacement = "") |>
    runjs()
  r"[$(document).ready($('#vitalDynamics-card > div > div.checkbox')
                        .css('margin-bottom', '10px'))]" |>
    gsub(pattern = r"(\n\s*)", replacement = "") |>
    runjs()
  r"[$(document).ready($('#vitalDynamics-card > div')
                        .css({'padding':'10px'}))]" |>
    gsub(pattern = r"(\n\s*)", replacement = "") |>
    runjs()

# Functions, such as the solveAndRender dispatcher -----------------------------
  updateNumericInputs <- function(defaults, session) {
    if (any(is.null(dim(defaults)), dim(defaults)[1] != 1)) {
      warning("The `defaults` dataframe is not a single row!")
      print(defaults)
    }
    iwalk(defaults, \(value, inputId) {
      updateNumericInput(session, inputId, value = value)
    })
  }

  # Validation --------------------------------------------------------------
  ## Add all of the rules generated by rule function factories to a validator,
  ## and optionally condition those rules on condition.
  addRuleListToValidator <- function(validator, ruleList) {
    mapply(
      function(inputId, ruleVector) {
        ## inputId is intentionally recycled while adding the rules in
        ## ruleVector.
        mapply(validator$add_rule, inputId, ruleVector)
        validator$add_rule(inputId, sv_required())
      },
      names(ruleList),
      ruleList
    )

    ## Enable the validator and return it invisibly.
    validator$enable()
    invisible(validator)
  }

  ## NOTE: all inputs have the required rule automatically added.
  globalValidator <- addRuleListToValidator(
    InputValidator$new(),
    filter(rules, is.na(model))[, 2][[1]][[1]]
  )

  validatorsAndLambdas <-
    filter(rules, !is.na(model)) |>
    rowwise() |>
    mutate(vld = list(addRuleListToValidator(InputValidator$new(), ruleList)),
           ## The body of the lambda may need to be embraced.
           lambda = list(eval(bquote(\() input$modelSelect == .(model))))) |>
    select(vld, lambda)

  ## NOTE: condition each validator upon its corresponding lambda, and then add
  ## each validator to the global validator as a child.
  isolate(
    mapply(
      FUN = \(validator, lambda) {
        validator$condition(lambda)
        ## NOTE: the return value of the previous statement is unused. It's
        ## void!
        globalValidator$add_validator(validator)
      },
      validatorsAndLambdas[[1]],
      validatorsAndLambdas[[2]]
    )
  )

  # Reactives ---------------------------------------------------------------
  defaults <- reactive({
    if (!(input$modelSelect %in% "")) {
      filter(
        defaultInputValues,
        modelType == input$modelSelect,

        ## FIXME: using logicals in any way seems to bork everything.
        stochastic == input$stochastic,
        vitalDynamics == input$vitalDynamics,
        massAction == input$trueMassAction
      ) |>
        select(beta:replicates) |>
        select(where(\(x) all(!is.na(x))))
    }
  })

  ## FIXME: https://shiny.posit.co/r/articles/build/images/
  output$modelDiagram <- renderUI({
    req(input$modelSelect)
    if (input$modelSelect %in% "") {
      tagList(
        img(
          src = "",
          alt = "No model selected; no image available.",
          contentType = "image/png",
          height = "40px"
        )
      )
    } else {
      tagList(
        img(
          src = here("www", "images", paste0(input$modelSelect, ".png")),
          contentType = "image/png",
          height = "40px",
          alt = "The diagram of the model compartments failed to load, or the accessibility text is being read by a screen reader."
        )
      )
    }
  })

  modellingFunctions <-
    reactive({
      mget(
        paste0(
          c("solve", "plot", "plotPhasePlane"),
          input$modelSelect
        ),
        envir = environment(solveSusceptibleInfected),
        mode = "function"
      )
    })

  # Observables -------------------------------------------------------------
  # MODEL SELECT: update numeric inputs to model defaults on change. --------
  ## Whenever the model selection changes (whether the parameters and variables
  ## are set manually or taken from pre-defined models), the widget values
  ## throughout the application are updated as appropriate.
  observeEvent(input$modelSelect, {
    ## If no model is selected, hide the model configuration and action buttons.
    if (input$modelSelect %in% "") {
      hide("actionButtons")
      hide("modelConfiguration")
    } else {
      ## Widget visibility and labelling
      hide("outputPanel")
      updateNumericInputs(defaults(), session)
      ## NOTE: this triggers the anonymous function in
      ## www/whenModelSelectChangesTypesetLaTeX.js to be called, typesetting the
      ## updated labels.
      if (grepl("SI", input$modelSelect, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[Rate of infection ($ \beta $)]")
        updateNumericInput(session, "gamma", r"[Rate of recovery ($ \gamma $)]")
      } else if (grepl("SEI", input$modelSelect, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[Rate of exposure ($ \beta $)]")
        updateNumericInput(session, "gamma", r"[Rate of infection ($ \gamma $)]")
      }
      show("modelConfiguration")
      show("actionButtons")

      ## FIXME: RStudio's MathJax is broken, and calling it borks reactivity.
      ## runjs(modelSelectJavaScript)
    }
  })

  # StochasticSelect --------------------------------------------------------
  ## NOTE: hide the output panel and update the input widgets with defaults when
  ## the user changes to stochastic modelling.
  observeEvent(input$stochasticSelect, {
    hide("outputPanel")
    updateNumericInputs(defaults(), session)
  })

  # GO: show outputPanel; call modelling function; render LaTeX. ------------
  ## Toggle the visibility of the outputPanel based on the user's interactions
  ## with the "go" actionButton.
  observeEvent(input$go, {
    show("outputPanel")

    modelSolver <- modellingFunctions()[[1]]
    modelPlotter <- modellingFunctions()[[2]]
    modelPhasePlanePlotter <- modellingFunctions()[[3]]

    eval(substitute({
      inputs <- reactiveValuesToList(input)
      modelResults <- doCall.default(
        .fcn = modelSolver,
        args = inputs,
        .ignoreUnusedArguments = TRUE
      )
      output$modelPlot <- renderPlot(modelPlotter(modelResults))
      output$modelPhasePlane <- renderPlot(modelPhasePlanePlotter(modelResults))
      output$modelSummaryTable <- DT::renderDataTable(DT::datatable(modelResults[, 1:6]))
      output$modelLaTeX <- renderUI(renderModelLaTeX(inputs))

      output$downloadData <- downloadHandler(
        filename = function() {
          paste(input$modelSelect, "_Model_Summary", Sys.Date(), ".xlsx", sep = "")
        },
        content = function(file) {
          writexl::write_xlsx(modelResults[, 1:6], file)
        }
      )

      ## FIXME: RStudio's MathJax is broken, and calling it borks reactivity.
      ## runjs(modelSelectJavaScript)
    }))
  })


  # RESET: hide outputPanel; modelConfiguration; actionButtons; rese --------
  ## TODO: resetting the application should set the widget values to those which
  ## are defined for the model in the spreadsheet.
  observeEvent(input$resetAll, {
    ## Widget visibility
    hide("outputPanel")
    hide("actionButtons")
    hide("modelConfiguration")

    ## Model options widget values
    updatePickerInput(session, "modelSelect", selected = "")
    updateRadioButtons(session, "trueMassAction", selected = 0)
    updateRadioButtons(session, "stochasticSelect", selected = 0)
    updateCheckboxInput(session, "vitalDynamics", value = FALSE)

    ## Simulation options widget values
    updateNumericInput(session, "timesteps", value = 100)

    ## FIXME: RStudio's MathJax is broken, and calling it borks reactivity.
    ## runjs(modelSelectJavaScript)
  })

  ## FIXME: the input is not being validated properly, because the global
  ## validator is returning the incorrect value and "go" is never being enabled.
  ## observeEvent(input, {
  ##   if (globalValidator$is_valid()) {
  ##     enable("go")
  ##   } else {
  ##     disable("go")
  ##   }
  ## })
}
